//
//  HomeInteractor.swift
//  PollutionApp
//
//  Created by Łukasz Drożdż on 30.07.2018.
//  Copyright (c) 2018 Łukasz Drożdż. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol HomeBusinessLogic
{
  func fetchAllStations()
	func searchForCity(withName name: String?)
	func fetchSensors(forStation station: Station)
	func stationsFor(selectedCity city: City)
}

protocol HomeDataStore
{
  //var name: String { get set }
	var stations: [Station] { get set }
	var cities: [City] { get set }
	var searchedCities: [City] { get set }
	var stationsInCities: [City: [Station]] { get set }
	var sensorsInCity: [Sensor] { get set }
}

class HomeInteractor: HomeBusinessLogic, HomeDataStore
{
	
	var presenter: HomePresentationLogic?
	var worker: HomeWorker?
	
	// All stations from API
	var stations: [Station] = []
	// Available cities from API
	var cities: [City] = []
	// Keeps cities that names contains type characters
	var searchedCities: [City] = []
	// Data is duplicated station, but this way its easier to show all station for city
	var stationsInCities: [City: [Station]] = [:]
	var sensorsInCity: [Sensor] = []
	
	// MARK: Do something
	
	func fetchAllStations() {
		worker = HomeWorker()
		worker?.fetchAllStations(completion: { (stations, error) in
			if let error = error {
				self.presenter?.presentError(withDescription: error.localizedDescription)
				return
			}
			
			if let stations = stations {
				self.stations = stations
				self.cities = self.sortCities(fromStations: stations)
				// For future navigating, its easier to have stations assigned to given city
				stations.forEach({ (station) in
					if self.stationsInCities[station.city] == nil {
						self.stationsInCities[station.city] = [station]
					} else {
						self.stationsInCities[station.city]! += [station]
					}
					
				})
				
				self.presenter?.presentSuccess()
			}
		})
	}
	
	func fetchSensors(forStation station: Station) {
		worker = HomeWorker()
		worker?.fetchSensors(forStation: station, completion: { (sensors, error) in
			if let error = error {
				self.presenter?.presentError(withDescription: error.localizedDescription)
				return
			}
			
			if let sensors = sensors {
				self.sensorsInCity = sensors
				self.presenter?.presentSensorsSuccess()
			}
		})
	}
	
	func searchForCity(withName name: String?) {
		guard let name = name else {
			return
		}
		
		let filteredCities = cities.filter({ $0.name.lowercased().contains(name.lowercased()) })
		self.searchedCities = filteredCities
		presenter?.presentSearchedCities()
	}
}

extension HomeInteractor {
	
	func stationsFor(selectedCity city: City) {
		guard let stations = stationsInCities[city] else {
			return
		}
		self.stations = stations
	}
	
	fileprivate func sortCities(fromStations stations: [Station]) -> [City] {
		let citiesTemp = stations.compactMap({ $0.city })
		// Get rid of duplicates
		let citiesWithoutDuplicates = Array(Set(citiesTemp))
		// Sort alphabetically
		return citiesWithoutDuplicates.sorted(by: {$0.name < $1.name})
	}
}
